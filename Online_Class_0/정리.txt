인텔리제이 설정에서 gradle버전과 JDK버전 잘 맞추기

스프링 부트는 크게 뷰와 컨테이너 이렇게 두 가지로 작동함
컨테이너가 컨트롤러를 찾고 컨트롤러가 매핑된 url이 호출되면
해당 메소드와 관련된 방향으로 작업을 처리함
ex) viewResolver, StringHttpMessageConverter,
MappingJackson2HttpMessageConverter 등등

@Controller 어노테이션
해당 Class를 스프링 컨테이너가 컨트롤러로 인식하게끔하는 어노테이션
컨테이너가 클래스를 객체로 만들어서 가지고 있는 형태를 빈이라고한다

@GetMapping("url에 포함될 특정 문자열")
url에 포함될 값에 객체를 할당시켜서 컨트롤러에게 방향을 제시
ex) locallhost:8080/hello 여기서 hello를 말하는 것

컨트롤러가 매핑된 객체에서 모델 어트리뷰트로 값을 지정하면
뷰에서 thymeleaf템플릿에서 제공하는 메소드자리에 넣어준다.

cmd창에서 빌드하고 실행하기
./gradlew build
2. cd build/libs
3. java -jar hello-spring-0.0.1-SNAPSHOT.jar

1.gradlew.bat build or gradlew build
2. cd build/libs
3. java -jar hello-spring-0.0.1-SNAPSHOT.jar

*에러발생시 clean build명령으로 빌드해보기

정적 뷰의 경우 static 폴더에 생성하고

컨트롤러 없이 바로 화면에 출력됨
컨테이너가 컨트롤러를 호출해 이 주소로 매핑된 객체가 있는지 확인
없기때문에 정적뷰탭을 확인 찾은 html파일을 그대로 페이지에 출력

@RequestParam(변수명)
url에 매핑된 문자열 뒤로 ?변수명=값 형태로 값이
주어지는것을 선언하는 어노테이션
* 객체선언 부에서 선언
* 어노테이션으로 파라미터 선언 후 변수 선언도 해줘야 메소드에서 사용할 수 있음
위에서 직접 문자열을 모델 어트리뷰트에 넣어서 모델를 뷰 리졸버로 넘겨주듯이
url의 파라미터가 가지는 해시맵 형태의 값을 [ex){name:"Spring"}]
모델 어트리뷰트형태로 뷰 리졸버로 넘겨서 thymleaf메소드에 뿌려주는 방식

(API방식)
@ResponseBody
컨트롤러가 해당 url정보를 가진 객체를 호출했을때
위의 어노테이션이 붙어있으면 리턴된 값이 객체인지 문자열인지에 따라
뷰리졸버대신에 다른 기능을하는 컨버터 등을 호출함

[문자열]
StringHttpMessageConverter가 호출되어 모델 어트리뷰트에 있는 문자열을
문자열 그대로 페지에 출력 (html형태 X)

[객체]
MappingJackson2HttpMessageConverter가 호출되어 객체를 JSON형태로 변환해
페이지에 출력

서버와 클라이언트가 소통하는 경우엔 위의 방식으로 페이지에 출력해주는 흐름이지만
서버와 서버가 값을 교환하는 경우 JSON형태로 값을 교환 -> RestAPI방식

회원 등록 기능 구현
회원 객체(Member.class)
 ㄴ회원이 가지게 될 정보의 종류 ex) id, name 등.. 을 구현

회원 리포지토리 인터페이스(MemberRepository.interface)
 ㄴ추상 메소드들로 일단 구현 원래 DB연결부가 들어가는 부분

회원 리포지토리 메모리 구현체(MemoryMemberRepository)
 ㄴ 인터페이스에 구현된 추상 메소드 들을 implements해서
    서비스들은 구현 마찬가지로 원래 DB연결부가 들어가는 부분
    이 때 실무에서는 동시성 문제가 발생 할 수 있기 때문에
    ConcurrentHashMap, AtomicLong 사용을 고려

& 일반 클래스와 추상 클래스의 차이점
1. 추상 메소드의 사용가능 여부
2. 클래스 내에서 객체 생성 가능 여부
* 추상 클래스는 사용하지 않아도 되지만 자식클래스에서 사용해야하는 기능들을
미리 열거해놓는 느낌 implements로 한번에 자식 클래스로 가져오기도 용이

& 추상 클래스와 인터페이스의 차이점
1. 자식클래스에서 상속받을 수 있는 개수
2. 메소드 몸체 구성 여부, 일반 변수 사용 가능 여부

& Interface로 선언된 객체 = new 해당 Interface가 impelements된 class
  MemeberRepository memberRepository = new MemoryMemberRepository
     (Interface)    (객체를 담을 변수)        (impelements된 class)

[테스트 구현제]
main메소드를 통해 실행해서 제대로 동작하는지 테스트하기에는 적합하지 않음
jUnit프레임워크를 통해 테스트를 전용 class를 생성해 테스트

MemoryMemberRepository에 구현한 기능들을 테스트하기 위해
test폴더아래에 MemoryMemberRepositoryTest class를 생성
기능을 테스트 할 수 있게 회원객체에 알맞은 값들을 임의로 넣어서 초소형 DB를 구현 후
각각에게 알맞은 메소드를 호출하거나 (getter, setter)
메소드에 파라미터에 값을 지정해주거나 하는 기능을 구현 후
메소드의 리턴값과 임의로 만들어놓은 회원객체를
비교해서 서로 같으면 True를 반환하는형태로 테스트
assertThat으로 회원객체를 비교대상을 지정 후
메소드 체이닝을 통해 isEqualTo()와 같은 메소드로
객체를 비교할 수 있음 두 객체가 같으면 True를 반환하여 테스트가 Sucess를 출력함

테스트 클래스를 통째로 테스트 할 때 메소드를 여러개 한번에 테스트 하게되면
메소드의 동작 순서를 보장 할 수 없기 때문에 일부 테스트 메소드들이
다른 값을 리턴받거나 하는 현상이 발생함 이를 해결하기 위해
하나의 메소드가 종료되면 해당 리포지토리값을 클리어해주어야함
store.clear()를 이용하여 객체를 생성하고 이것을
테스트 케이스의 맨 상단부에 메소드로 구현하여
다른 메소드가 끝날때마다 클리어되게끔 함

[서비스 구현체]
구현하고 자하는 서비스들을 각각 기능에 알맞게 구현
서비스 구현체의 메소드 이름은 개발자Role이 아님
비 전공자들이 다른 업무에서 직접적으로 개입하는 부분이기 때문에
그 사람들이 정한 해당 기능의 명칭을 따르거나 어떤 방식이든 통일하는것이 좋음
* 리포지토리 메소드들의 매개변수와 리턴값의 형태를 이해하는것이 중요

@AfterEach
테스트 케이스의 메소드들이 실행될때 하나의 메소드가 종료 후에
이 어노테이션의 있는 메소드를 실행해라 라는 의미

@BeforeEach
테스트 케이스의 각각의 메소드들이 실행되기전에
이 어노테이션의 있는 메소드를 실행해라 라는 의미

[서비스 테스트 구현체]
서비스 테스트 메소드의 기본은 given when then이다.
given 서비스에 사용되는 값은 뭔지
when 서비스를 마치고 리턴되는 정보를 저장하는 구문
then when구문에 리턴된 값을통해 해당 서비스 테스트가 정상적으로 진행됬는지 확인하는 구문

[스프링 컨테이너]
클래스들을 빈으로 등록해서 서비스빈 컨트롤러빈 리파지토리빈 등이 DI상태로 대기하도록
하다가 서로 해당 객체나 메소드가 필요할때 주입시켜주는 형태
@Cotroller
@Service
@Repository

@Component
위의 어노테이션들을 지원해주는 클래스에 들어가보면 모든 어노테이션의 기본형은@Component임을
알 수 있다.

메인패키지와 동일한 계층이나 하위계층은 어노테이션으로 구분해 자동으로 빈으로 등록되지만
더 상위계층은 등록되지않음 추가적이 작업필요

컨테이너에 class들을 빈으로 등록하는 방법은 위 처럼 어노테이션을 이용하는 방벙과
직접 자바 코드를 이용하는 방법 이렇게 두 가지가 있다.

직접 자바 코드로 작성하면 Config.java 클래스를 하나 생성해서
@Configuration, @Bean어노테이션과 메소드로 DI관계를 만들 수 있다.

직접자바 코드로 DI관계를 만들어 주면 조금 번거롭긴하지만 프로젝트를 구성할때
임의의 레파지토리가 DB역할을 하게끔 구성하고 나중에 DB를 연동하게 된다
이 때 다른 코드를 하나도 건들이지않고 Config.java 파일에서 약간만 수정해주면
레파지토리와 연결되어있던 메소드가 DB와 연동되고 바로 이용할 수 있다.

[JPA]
ORM Object Relational Mapping
어노테이션을 통해 DB와 연동하는 프레임워크
@Entity         객체를 JPA가 관리하는 엔티티로 인식하게 해주는 어노테이션
@Transactional  JPA는 회원가입(Join)등의 기능이 작동할 때 이를 하나의 트랜잭션으로 묶어주어야함
@Id             Primary Key를 인식하게 해주는 어노테이션
@GeneratedValue DB에서 값이 자동으로 증가하는 기능을 인식하게 해주는 어노테이션
SpringDataJPA 프레임워크와 함께 이용하면 간단한 쿼리문들을 더 간단하게 사용할 수 있다
[SQL]  === JPAfr ==> [JPQL] === SpringDataJPAfr ==> [Interface로만 이루어진 쿼리문]

[AOP]
@Aspect     해당클래스를 AOP로 동작하게 해주는 어노테이션
@Component  AOP클래스를 bean으로 등록
@Around     적용대상 지정

