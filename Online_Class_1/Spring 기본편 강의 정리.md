# Spring 기본편 강의

- 스프링 컨테이너를 거의 사용하지 않고 POJO로만 간단한 회원 관리 서비스를 구현해보는 스프링 프로젝트
- 테스트 구현체와 빈, 스프링컨테이너, DI, IOC, 싱글 톤 등의 개념을 이해하기 위해 약간의 스프링 어노테이션은 사용합니다.

## 서비스 로직

### 할인 정책

1. 할인 정책 인터페이스 (interface)
    
    회원 객체와 int형 가격을 매개변수로 하는 메서드를 정의
    
2. 고정 할인 정책 구현체 (class)
    
    회원 객체의 등급을 비교해 등급이 VIP라면 1000원을 고정할인해주는 정책
    
3. 정률 할인 정책 구현체 (class)
    
    회원 객체의 등급을 비교해 등급이 VIP라면 전체금액의 10%를 할인해주는 정책
    

### 회원 시스템

1. 회원 등급 상수 모음 (enum)
    
    회원 객체에서 등급을 담당하는 Grade형을 만들어주는 상수모음
    
2. 회원 정보 객체 (class)
    
    아이디, 이름, 등급 정보로 구성된 회원 객체
    Contructor로 인스턴스 생성을 편하게 하고
    Getter, Setter로 객체 인스턴스를 참조 할 수 있게합니다.
    
3. 회원 서버 로직 인터페이스 (interface)
    
    회원 객체를 저장하는 메서드 save
    아이디를 매개변수로 멤버를 찾아서 리턴해주는메서드findById를 정의
    
    지금은 메모리 구현체에 저장하는 형식이지만
    후에 DB 구현체가 들어와도 작동할 수 있게끔 추상화하는 역할
    (ex) JDBC, SDJPA → MySQL, MongoDB..등)
    
4. 회원 클라이언트 로직 인터페이스 (interface)
    
    회원 객체를 저장하는 메서드join
    아이디를 매개변수로 멤버를 찾아서 리턴해주는메서드findMember를 정의
    
    클라이언트가 요청할 수 있는 메서드 목록을 정의
    
5. 서버 메모리 구현체 (class)
    
    해시맵형태의 객체를 선언해 save메서드가 호출되면 입력받은 회원정보를 이용해
    회원아이디 : 회원객체 형태로 저장하는 로직
    
    회원아이디 : 회원객체 형태의 해시맵에서 key인 멤버아이디를 이용해
    value인 멤버객체를 찾아서 리턴해주는 메서드 findById
    
6. 클라이언트 서비스 구현 (class)
    
    클라이언트가 요청할 수 있는 메서드들을 구현
    
    클라이언트가 회원가입을 원할 때 join메서드를 호출해
    메모리 구현체 혹은 DB구현체의 저장(ex) save, insert, persist…등등)
    
    클라이언트에서 회원 정보를 조회하고싶다고 하면 회원ID를 입력하면
    ID를 매개변수로 메모리 구현체 혹은 DB구현체의 조회 메서드를 호출하여
    회원정보를 리턴해줍니다. (ex) findById, select, find…등등)
    

### 주문 시스템

1. 주문 정보 객체 (class)
    
    주문에 필요한 회원아이디 상품이름 상품가격 할인정책이 리턴해준 가격으로 구성된 객체
    Contructor로 인스턴스 생성을 편하게 하고
    Getter, Setter로 객체 인스턴스를 참조 할 수 있게합니다.
    
2. 주문 로직 인터페이스 (interface)
    
    주문 생성 메서드를 정의
    
3. 주문 서비스 구현체 (class)
    
    주문을 요청한 회원의 정보와 회원정보를 토대로한 할인율을 종합하여
    하나의 주문으로 만들어 주문 인스턴스를 새로만들어서 리턴해준다.
    

### 기타

1. 순수자바 멤버 서비스 테스트 객체 (class)
2. 순수 자바 오더 서비스 테스트 객체 (class)
3. 시스템 Config 객체 (class)
    
    스프링 컨테이너, 빈 사용법 실습
    의존관계주입 DI와 제어의 역전 IOC 개념 익히기
    싱글톤 객체 생성의 개념 익히기
    
4. xml로 하는 Config파일 (xml)
    
    xml을 통한 DI와 IOC실습
    

## 테스트 로직

1. 회원 테스트
    
    회원 인스턴스가 잘 생성되는지 확인하고 메모리구현체에 잘 저장되는지 확인한다.
    
2. 할인 정책 테스트
    
    정률할인정책을 이용해 회원의 등급에 따라 할인이 적용되는지 확인한다.
    
3. 주문 테스트
    
    주문인스턴스를 생성하고 할인이 잘 적용됬는지 확인해 주문생성 메서드가 잘 작동하는지 확인한다.
    
4. 스프링 컨테이너에 등록된 빈의 정보 조회
    
    AnnotationConfigApplicationContext
    GenericXmlApplicationContext
    
    두 객체에 .getBeanDefinition을 통해서 빈의 구성 정보를 출력한다
    
5. 스프링 컨테이너에 등록된 빈 조회
    1. 이름 및 타입으로 조회
        
        빈 이름이나 빈 타입으로 빈을 찾아서 객체 클래스와 비교해서 테스트합니다.
        
    2. 상속관계로 조회
        
        상속관계를 통해 빈을 조회할 때는 자식 클래스가 둘 이상있으면 발생하는 부분과 둘 이상의 자식클래스가 있을 경우 빈의 이름을 지정해주면 지정된 이름을 가진 빈을 가져온다. 그리
        
    3. 전체 빈 및 역할별 빈 조회
        
        빈의 ROLE을 지정해주면 확인이 필요한 부분만 확인할 수 있다.
        (ex) ROLE_APPLICATION [사용자가 정의한 빈],
               ROLE_INFRASTRUCTURE [스프링이 내부에서 사용하는 빈])
        
    4. 빈 중복 테스트
        
        자식클래스가 두개있는 부모클래스를 조회하거나 실제로 같은 이름의 빈을 두개 등록했을 경우에 빈을 조회하면 발생하는 NoUniqueBeanDefinitionException을 캐치해서 테스트한다. 부모로 상속 라인 모두 조회하기, 특정 타입으로 생성된 객체 모두 조회하기를 할때 해시맵 형태로 리턴받아서 모두 출력할 수 있다.
        
6. xml로 생성자 주입 테스트
    
    xml을 이용한 DI,IOC를 테스트한다.
    
7. 싱글톤 테스트
    
    private로 static영역에 인스턴스를 하나 생성하는 간단한 서비스 구현체를 하나 만들어주고
    getInstance메서드를 통해 객체가 필요할때마다 생성하는 구조가 아닌 이미 생성되어져 있는 인스턴스를 가져오는 구조를 테스트한다.
    
    AnnotationConfigAplicationContext를 이용한 싱글톤 패턴을 구성한다. Member 객체를 AppConfig
    

### 강의 내용 중 헷갈리는 부분 및 처음 보는 부분

부모 타입으로 조회하면 자식 전부 조회 됨

디자인 패턴 검색해보기

configuaration 어노테이션의 싱글톤 지원 서비스는 Bean으로 등록된 메서드가 정적메서드라면 지원받지 못합니다. 인스턴스로 생성해서 사용하지않고 객체 자체를 이용하는 방식으로 이용되기때문입니다….?

CGLIB라는 바이트코드 조작 라이브러리를 사용해서 AppConfig
클래스를 상속받은 임의의 다른 클래스를 만들고, 그 다른 클래스를 스프링 빈으로 등록한 것

@ComponentScan 어노테이션은 하위 패키지의 @Component 어노테이션을 찾아서 빈으로 등록하는 개념입니다. 다른 패키안에 넣어놓으면 그 패키지의 하위 패키지를 스캔하기 때문에 제대로 동작하지 않을 수 있습니다.

어노테이션의 옵션으로
basePackages = "hello.core”
을 넣어서 지정해 줄 수도 있다.
하지만 권장하는 방법은 실제로 hello.core와 같은 최상단패키지밑에 바로 AutoConfig클래스를 생성하여 동작 시크는것이 좋다.

basePackages : 컴포넌트 스캔 시작 패키지를 지정한다.
includeFilters : 컴포넌트 스캔 대상을 추가로 지정한다.
excludeFilters : 컴포넌트 스캔에서 제외할 대상을 지정한다

FilterType 옵션
ANNOTATION: 기본값, 애노테이션을 인식해서 동작한다.
ASSIGNABLE_TYPE: 지정한 타입과 자식 타입을 인식해서 동작한다.
ASPECTJ: AspectJ 패턴 사용
*REGEX: 정규 표현식*
CUSTOM: TypeFilter 이라는 인터페이스를 구현해서 처리

@Component : 컴포넌트 스캔에서 사용
@Controlller : 스프링 MVC 컨트롤러에서 사용
@Service : 스프링 비즈니스 로직에서 사용
@Repository : 스프링 데이터 접근 계층에서 사용
@Configuration : 스프링 설정 정보에서 사용

어노테이션마다 실질적으론 개발자들을 위한 이름표 역할을 하는 어노테이션도 있고
데이터계층의 시스템을 스프링이 통제하게하거나 MVC와같은 시스템을 스프링이 통제하게 하는등의 역할을 지정해주는 어노테이션들로 이루어져있다.
또 순수 자바에서도 지원하는 기능을 코드를 간결하게 만들어 주기 위해 존재하는 어노테이션도 있다. → lombok라이브러리

자동 빈 등록과 수동 등록 빈이 이름이 같으면 수동 등록 빈이 우선권을 가지게 된다.
이 현상을 의도해서 개발을 진행하는 경우보다는 설정이 꼬이면서 이 현상이 발생하는 경우가 많고
이 현상과 엮여서 버그가 생기게되면 잡아내기가 힘들다. 그래서 SpringBoot의 기본설정은
spring.main.allow-bean-definition-overriding=false
로 되어있어 똑같은 이름의 빈이 두 개 있다라는 에러를 출력한다.

테스트단에서는 Springboot없이 메소드들만 실행하기때문에

spring.main.allow-bean-definition-overriding=true 설정과 같이 작동해 자동 등록 빈을 비활성화 시키고 수동 등록 빈을 통해 작동한다.

의존 관계 주입

1. 생성자를 통한 주입 (가장 유리함)
생성자가 생성되는 라이프 사이클에 의존관계도 함께주입
    
    생성자 주입이 유리한 이유
    의존 관계는 불변이라는 특징을 가지기 때문이다.
    대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다. 오히려
    대부분의 의존관계는 애플리케이션 종료 전까지 변하면 안된다.(불변해야 한다.)
    수정자 주입을 사용하면, setXxx 메서드를 public으로 열어두어야 한다.
    누군가 실수로 변경할 수 도 있고, 변경하면 안되는 메서드를 열어두는 것은 좋은 설계 방법이 아니다.
    생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로 이후에 호출되는 일이 없다. 따라서 불변하게 설계할
    수 있다.
    
    위의 이유와 같이 final 키워드를 통해 의존관계주입이 이루어지는 객체들을 서비스 로직에서 선언할 때 
    
2. 수정자(setter)를 통한 주입
2번째 의존관계만 주입하는 라이프 사이클에서 주입 됨
// 3,4,번 보다는 사용 빈도가 있지만 거의 사용 안함
3. 필드 주입
필드 단에서 @Autowired를 통해 생성자 주입 // 거의 사용 안함
4. 일반 메서드 주입
일반 메서드를 통해 생성자를 주입  // 거의 사용 안함

최신 트렌드인 lombok

lombok라이브러리를 통해 생성자를 만들지않고 의존성 주입이 가능하다.

lombok을 사용하는 인텔리제이 프로젝트의 경우 초기 설정이 필요하다.
1. lombok플러그인이 깔려있는지 확인
2. Annotation Processors 옵션이 켜져있는지 확인
ex) @Getter, @Setter, @ToString, @RequiredArgsConstructor

@Autowired 어노테이션이 의존성을 주입해줄때의 특징
ac.getBean을 통해 빈을 조회할 때와 똑같이 타입으로 가져와 주입을 시도하고 자식 객체가 여러개라면 ex) DiscountPolicy →  Fix, Rate
오류가 난다.

NoUniqueBeanDefinitionException ⇒ UnsatisfiedDependencyException

이 때 생성자의Autowired에선 파라미터명 필드 Autowired에선 필드명
을 지정해주면 타입 비교 후 이름을 비교해서 가져온다.

@Qualifier("mainDiscountPolicy") 어노테이션을 통한 지정도 해줄 수 있다.
@Qualifier경우 @Qualifier와 매칭하는 경우에만 사용한다.

@Primary 같은 타입의 여러가지 자식 구현체 중 @Primary이 붙어있는 클래스를 무조건 먼저 등록하는 방향으로 구성해주는 어노테이션

@Primary보다는 @Qualifier가 우선순위가 더 높다

정리
편리한 자동 기능을 기본으로 사용하자
직접 등록하는 기술 지원 객체는 수동 등록
다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민해보자

@PostConstruct, @PreDestroy 애노테이션 특징
최신 스프링에서 가장 권장하는 방법이다.
애노테이션 하나만 붙이면 되므로 매우 편리하다.
패키지를 잘 보면 javax.annotation.PostConstruct 이다. 스프링에 종속적인 기술이 아니라 JSR-250
라는 자바 표준이다. 따라서 스프링이 아닌 다른 컨테이너에서도 동작한다.
컴포넌트 스캔과 잘 어울린다.
유일한 단점은 외부 라이브러리에는 적용하지 못한다는 것이다. 외부 라이브러리를 초기화, 종료 해야 하면
@Bean의 기능을 사용하자.

정리
@PostConstruct, @PreDestroy 애노테이션을 사용하자
코드를 고칠 수 없는 외부 라이브러리를 초기화, 종료해야 하면 @Bean 의 initMethod , destroyMethod
를 사용하자.

**싱글톤**: 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다.
**프로토타입**: 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는
매우 짧은 범위의 스코프이다.

스코프를 통한 프로토타입 빈

정리
여기서 핵심은 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다는
것이다. 클라이언트에 빈을 반환하고, 이후 스프링 컨테이너는 생성된 프로토타입 빈을 관리하지 않는다.
프로토타입 빈을 관리할 책임은 프로토타입 빈을 받은 클라이언트에 있다. 그래서 @PreDestroy 같은 종료
메서드가 호출되지 않는다.

싱글톤 빈에서 프로토타입 빈을 주입해 사용할 때는 해당 프로토타입 빈도 싱글톤처럼 작동한다. 하지만 이런 경우의 개발의 목적으로는 각 클라이언트의 요청마다 각각의 적용이되면서 클라이언트의 요청을 처리하는 빈은 싱글톤으로 유지하고싶다 이 때 직접 스프링컨테이너에서 프로토타입 빈을 새로 주입해달라고 요청 (ApplicationContext 객체를 통해)해서 진행할 수 도있지만 비효율적이다.

ApplicationContext는 getBean뿐만 아니라 스프링 컨테이너와 상호작용 하는 포괄적인 기능이 담긴 객체이다 하지만 우리가 필요한건
Dependency Lookup(DL)기능만 있으면 된다.

DL기능만 제공하는 ObjectFactory와 자식으로 ObjectProvider가 있다.
ObjectProvider는 DL기능과 약간의 편의 기능을 같이 제공한다.

jakarta.inject.Provider정확하게 DL기능만 지원하는 자바 표준
라이브러리이다.

httpRequest와 Provider를 활용하고 @Scope(value = "request")타입의 싱글톤으로 유지되지않는 빈을 활용하여 각 클라이언트가 httpRequest요청했을때 Provider를 활용해 서로 다른 request타입의 객체를 제공한다.

위와 같은 기능을 지원하는 프록시 기능
@Scope어노테이션의 옵션으로 proxy옵션을 줘서 스프링컨테이너가  Provider의 역할도 하게끔 할 수 있다. 일단은 해당 객체의 진짜 모습을 찾아가는 방법을 들고있는 가짜 프록시 객체를 만들어 이름을 똑같이 해서 지연 처리한다.

핵심
사실 Provider를 사용하든, 프록시를 사용하든 핵심 아이디어는 진짜 객체 조회를 꼭 필요한 시점까지
지연처리 한다는 점이다.