인텔리제이 설정에서 gradle버전과 JDK버전 잘 맞추기

스프링 부트는 크게 뷰와 컨테이너 이렇게 두 가지로 작동함
컨테이너가 컨트롤러를 찾고 컨트롤러가 매핑된 url이 호출되면
해당 메소드와 관련된 방향으로 작업을 처리함
ex) viewResolver, StringHttpMessageConverter,
MappingJackson2HttpMessageConverter 등등

@Controller 어노테이션
해당 Class를 스프링 컨테이너가 컨트롤러로 인식하게끔하는 어노테이션
컨테이너가 클래스를 객체로 만들어서 가지고 있는 형태를 빈이라고한다

@GetMapping("url에 포함될 특정 문자열")
url에 포함될 값에 객체를 할당시켜서 컨트롤러에게 방향을 제시
ex) locallhost:8080/hello 여기서 hello를 말하는 것

컨트롤러가 매핑된 객체에서 모델 어트리뷰트로 값을 지정하면
뷰에서 thymeleaf템플릿에서 제공하는 메소드자리에 넣어준다.

cmd창에서 빌드하고 실행하기
./gradlew build
2. cd build/libs
3. java -jar hello-spring-0.0.1-SNAPSHOT.jar

1.gradlew.bat build or gradlew build
2. cd build/libs
3. java -jar hello-spring-0.0.1-SNAPSHOT.jar

*에러발생시 clean build명령으로 빌드해보기

정적 뷰의 경우 static 폴더에 생성하고

컨트롤러 없이 바로 화면에 출력됨
컨테이너가 컨트롤러를 호출해 이 주소로 매핑된 객체가 있는지 확인
없기때문에 정적뷰탭을 확인 찾은 html파일을 그대로 페이지에 출력

@RequestParam(변수명)
url에 매핑된 문자열 뒤로 ?변수명=값 형태로 값이
주어지는것을 선언하는 어노테이션
* 객체선언 부에서 선언
* 어노테이션으로 파라미터 선언 후 변수 선언도 해줘야 메소드에서 사용할 수 있음
위에서 직접 문자열을 모델 어트리뷰트에 넣어서 모델를 뷰 리졸버로 넘겨주듯이
url의 파라미터가 가지는 해시맵 형태의 값을 [ex){name:"Spring"}]
모델 어트리뷰트형태로 뷰 리졸버로 넘겨서 thymleaf메소드에 뿌려주는 방식

(API방식)
@ResponseBody
컨트롤러가 해당 url정보를 가진 객체를 호출했을때
위의 어노테이션이 붙어있으면 리턴된 값이 객체인지 문자열인지에 따라
뷰리졸버대신에 다른 기능을하는 컨버터 등을 호출함

[문자열]
StringHttpMessageConverter가 호출되어 모델 어트리뷰트에 있는 문자열을
문자열 그대로 페지에 출력 (html형태 X)

[객체]
MappingJackson2HttpMessageConverter가 호출되어 객체를 JSON형태로 변환해
페이지에 출력

서버와 클라이언트가 소통하는 경우엔 위의 방식으로 페이지에 출력해주는 흐름이지만
서버와 서버가 값을 교환하는 경우 JSON형태로 값을 교환 -> RestAPI방식

회원 등록 기능 구현
회원 객체(Member.class)
 ㄴ회원이 가지게 될 정보의 종류 ex) id, name 등.. 을 구현

회원 리포지토리 인터페이스(MemberRepository.interface)
 ㄴ추상 메소드들로 일단 구현 원래 DB연결부가 들어가는 부분

회원 리포지토리 메모리 구현체(MemoryMemberRepository)
 ㄴ 인터페이스에 구현된 추상 메소드 들을 implements해서
    서비스들은 구현 마찬가지로 원래 DB연결부가 들어가는 부분
    이 때 실무에서는 동시성 문제가 발생 할 수 있기 때문에
    ConcurrentHashMap, AtomicLong 사용을 고려

& 일반 클래스와 추상 클래스의 차이점
1. 추상 메소드의 사용가능 여부
2. 클래스 내에서 객체 생성 가능 여부
* 추상 클래스는 사용하지 않아도 되지만 자식클래스에서 사용해야하는 기능들을
미리 열거해놓는 느낌 implements로 한번에 자식 클래스로 가져오기도 용이

& 추상 클래스와 인터페이스의 차이점
1. 자식클래스에서 상속받을 수 있는 개수
2. 메소드 몸체 구성 여부, 일반 변수 사용 가능 여부

& Interface로 선언된 객체 = new 해당 Interface가 impelements된 class
  MemeberRepository memberRepository = new MemoryMemberRepository
     (Interface)    (객체를 담을 변수)        (impelements된 class)

[테스트 구현제]
main메소드를 통해 실행해서 제대로 동작하는지 테스트하기에는 적합하지 않음
jUnit프레임워크를 통해 테스트를 전용 class를 생성해 테스트

MemoryMemberRepository에 구현한 기능들을 테스트하기 위해
test폴더아래에 MemoryMemberRepositoryTest class를 생성
기능을 테스트 할 수 있게 회원객체에 알맞은 값들을 임의로 넣어서 초소형 DB를 구현 후
각각에게 알맞은 메소드를 호출하거나 (getter, setter)
메소드에 파라미터에 값을 지정해주거나 하는 기능을 구현 후
메소드의 리턴값과 임의로 만들어놓은 회원객체를
비교해서 서로 같으면 True를 반환하는형태로 테스트
assertThat으로 회원객체를 비교대상을 지정 후
메소드 체이닝을 통해 isEqualTo()와 같은 메소드로
객체를 비교할 수 있음 두 객체가 같으면 True를 반환하여 테스트가 Sucess를 출력함

테스트 클래스를 통째로 테스트 할 때 메소드를 여러개 한번에 테스트 하게되면
메소드의 동작 순서를 보장 할 수 없기 때문에 일부 테스트 메소드들이
다른 값을 리턴받거나 하는 현상이 발생함 이를 해결하기 위해
하나의 메소드가 종료되면 해당 리포지토리값을 클리어해주어야함
store.clear()를 이용하여 객체를 생성하고 이것을
테스트 케이스의 맨 상단부에 메소드로 구현하여
다른 메소드가 끝날때마다 클리어되게끔 함

[서비스 구현체]
구현하고 자하는 서비스들을 각각 기능에 알맞게 구현
서비스 구현체의 메소드 이름은 개발자Role이 아님
비 전공자들이 다른 업무에서 직접적으로 개입하는 부분이기 때문에
그 사람들이 정한 해당 기능의 명칭을 따르거나 어떤 방식이든 통일하는것이 좋음
* 리포지토리 메소드들의 매개변수와 리턴값의 형태를 이해하는것이 중요

@AfterEach
테스트 케이스의 메소드들이 실행될때 하나의 메소드가 종료 후에
이 어노테이션의 있는 메소드를 실행해라 라는 의미

@BeforeEach
테스트 케이스의 각각의 메소드들이 실행되기전에
이 어노테이션의 있는 메소드를 실행해라 라는 의미

[서비스 테스트 구현체]
서비스 테스트 메소드의 기본은 given when then이다.
given 서비스에 사용되는 값은 뭔지
when 서비스를 마치고 리턴되는 정보를 저장하는 구문
then when구문에 리턴된 값을통해 해당 서비스 테스트가 정상적으로 진행됬는지 확인하는 구문

[스프링 컨테이너]
클래스들을 빈으로 등록해서 서비스빈 컨트롤러빈 리파지토리빈 등이 DI상태로 대기하도록
하다가 서로 해당 객체나 메소드가 필요할때 주입시켜주는 형태
@Cotroller
@Service
@Repository

@Component
위의 어노테이션들을 지원해주는 클래스에 들어가보면 모든 어노테이션의 기본형은@Component임을
알 수 있다.

메인패키지와 동일한 계층이나 하위계층은 어노테이션으로 구분해 자동으로 빈으로 등록되지만
더 상위계층은 등록되지않음 추가적이 작업필요

컨테이너에 class들을 빈으로 등록하는 방법은 위 처럼 어노테이션을 이용하는 방벙과
직접 자바 코드를 이용하는 방법 이렇게 두 가지가 있다.

직접 자바 코드로 작성하면 Config.java 클래스를 하나 생성해서
@Configuration, @Bean어노테이션과 메소드로 DI관계를 만들 수 있다.

직접자바 코드로 DI관계를 만들어 주면 조금 번거롭긴하지만 프로젝트를 구성할때
임의의 레파지토리가 DB역할을 하게끔 구성하고 나중에 DB를 연동하게 된다
이 때 다른 코드를 하나도 건들이지않고 Config.java 파일에서 약간만 수정해주면
레파지토리와 연결되어있던 메소드가 DB와 연동되고 바로 이용할 수 있다.

[JPA]
ORM Object Relational Mapping
어노테이션을 통해 DB와 연동하는 프레임워크
@Entity         객체를 JPA가 관리하는 엔티티로 인식하게 해주는 어노테이션
@Transactional  JPA는 회원가입(Join)등의 기능이 작동할 때 이를 하나의 트랜잭션으로 묶어주어야함
@Id             Primary Key를 인식하게 해주는 어노테이션
@GeneratedValue DB에서 값이 자동으로 증가하는 기능을 인식하게 해주는 어노테이션
SpringDataJPA 프레임워크와 함께 이용하면 간단한 쿼리문들을 더 간단하게 사용할 수 있다
[SQL]  === JPAfr ==> [JPQL] === SpringDataJPAfr ==> [Interface로만 이루어진 쿼리문]

[AOP]
@Aspect     해당클래스를 AOP로 동작하게 해주는 어노테이션
@Component  AOP클래스를 bean으로 등록
@Around     적용대상 지정


Spring기초

스프링의 특징
핵심 기술 : 스프링 컨테이너(DI), AOP, 이벤트…
웹 기술 : MVC, WebFlux
데이터 접근 기술 : 트랜잭션, JDBC, ORM, XML
기술 통합 : 캐시, 이메일, 원격접근, 스케줄링
테스트 : 자체적 테스트 지원
언어 : 코틀린, 그루비, 자바

스프링은 DB연동 및 웹사이트를 구현해주는 시스템
스프링 부트를 통해 스프링의 다양한 프레임 워크들을 편리하게 사용
스프링 부트의 특징
스프링을 편리하게 사용할 수 있도록 지원
단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
톰캣과 같은 웹 서버가 내장 되어있어서 따로 웹 서버를 연동하지 않아도 되서 편리함.
애플리케이션 모니터링에 편리한 기능들을 기본으로 제공
메트릭, 상태확인, 외부 구성과같은 프로덕션 준비 기능 등 제공
유명한 외부라이브러리들은 자동으로 호환이 용이한 버전으로 맞춰서 지원
개발 환경 설정이 편리하다
현재의 스프링이라는 명칭은 스프링의 DI를 지원하는 컨테이너와 여러가지 프레임 워크 스프링 부트까지 전체를 포함한 생태계 자체를 말한다.
스프링 = 스프링 컨테이너 + 스프링 부트 + 스프링 프레임워크
자바라는 객체 지향 언어의 강력한 특징을 살려내는 프레임워크
자바가 가지는 다형성과 SOLID의 OCP, DIP원칙을 연결시켜주어 객체 지향의 특징을 살려주는 것이 스프링컨테이너
여러 상황에 대처할 수 있는 인터페이스를 먼저 만들어놓고 상황에 맞는 기능 구현체를 갈아 끼울 수 있도록 애플리케이션을 개발하는 것. 하지만 근 시점에 확장 계획이 없다면 구현체 클래스를 직접 사용하고 향후 필요가 생겼을때 리펙터링으로 인터페이스를 도입하는 방식으로 개발하여 추상화 비용을 줄이는것도 중요함 이 둘의 장점과 단점을 잘 맞춰서 단점이 장점을 넘어서지 않는 특정 지점에 맞춰서 개발 하는 것이 중요



MVC
Servlet Stack
Servlet Containers
Servlet API
JDBC, JPA, NoSQL

온 블로킹을 기반으로 작동하고 사용자 인터페이스와 비즈니스 로직을 분리하여 비즈니스 로직을 수정해야하는 경우 전체적인 코드수정이 아닌 비즈니스 로직만을 수정할 수 있는 시스템을 개발할 수 있다.
하나의 쓰레드와 하나의 

FLUX
Reactive Stack
Netty, Servlet3.1+Containers
Reactive Stream Adapters
Mongo, Cassandra, R2DBC

논 블로킹을 기반으로한 함수형 엔드포인트를 사용할 수 있고 반복 이벤트에 대한 동시성을 적용한 모델을 지원한다.

1. **논블로킹(Non-blocking)**
    1. **논블로킹 알고리즘(Non-blocking Algorism)**
    어떤 쓰레드에서 오류가 발생하거나 멈추었을 때 다른 쓰레드에게 영향을 끼치지 않도록 만드는 알고리즘을 말합니다.
    2. **논 블로킹 입/출력(Non-blocking I/O)**
    입출력 처리는 시작만 해둔 채 완료되지 않은 상태에서 다른 처리 작업을 계속 진행할 수 있도록 멈추지 않고 입출력 처리를 기다리는 방법을 말합니다.
동시성(Concurrency)
각 프로그램 조각들이 실행 순서와 무관하게 동작할 수 있도록 만들어 한 번에 여러 개의 작업을 처리할 수 있도록 만든 구조입니다.

공통점 적용되는 다르지만 스프링 시큐리티 기반의 보안 로직을 구성한다.

서로 데이터 접근이 용이한 DB 종류가 다르다










































