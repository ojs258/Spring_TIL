# Spring Backend 기술 탐구 보고서

## 목차

1. **Spring**이란
2. 스프링의 핵심 기술
    1. 스프링 컨테이너(**Spring Container**)
        1. 어노테이션과 빈(**Annotation & Bean**)
        2. 싱글톤(**Singleton**)과 의존성
        3. 의존성 주입(**D**ependency **I**njection) as **DI** 와
        제어의 역전(**I**nversion **O**f **C**ontrol) as **IOC**
        4. 관심 지향 프로그래밍(**A**spect **O**riented **P**rogramming) as **AOP**
    2. 스프링 부트(**Spring Boot**)
        1. 스프링 부트의 정의
        2. 웹 서버(**Web Server**)
        3. 데이터 접근(**Data Access**)
            - 일관된 서비스 추상화****(P**ortable ****S**ervice ****A**bstraction****)**** as ****PSA**
    3. 스프링의 프레임워크(**Framework of Spring**)
3. 스프링의 웹 기술
    1. 웹 - 모델, 뷰, 컨트롤러 (**Web** - **M**odel, **V**iew, **C**ontroller) as **MVC**
    2. 웹 플럭스(**WebFlux**) as **FLUX**
    3. 둘의 공통점과 차이점 정리
4. 스프링의 데이터 접근 기술
    1. 트랜잭션(**Transaction**)
    2. 자바 데이터베이스 접속가능성(Java Database Connectivity) as **JDBC**
    3. 객체와 관계 매핑(**O**bject **R**elational **M**apping) as **ORM** 과
    자바 존속 API (**J**ava **P**ersistence **A**PI) as **JPA**와
    4. 확장형 마크업 언어 (E**x**tensible **M**arkup **L**anguage) as **XML**
5. 스프링의 테스트
    1. 자체적인 코드 테스트 지원
6. 스프링의 언어
    1. 자바(**Java**), 코틀린(**Kotlin**), 그루비(**Groovy**)

## 1. 스프링이란

스프링의 사전적 정의

> 엔터프라이즈용 Java 애플리케이션 개발을 편하게 할 수 있게 해주는 오픈소스 경량급 애플리케이션 프레임워크
순수 자바를 통해 생성한 객체(Plain Old Java Object) as POJO 와 DI/IOC, AOP, PSA등을 합친 애플리케이션 프레임워크
> 

현재 시점의 스프링이라는 명칭은

스프링 컨테이너 + 스프링 부트 +스프링의 프레임워크(모듈)이 세가지를 합쳐서 부르는 말입니다.

또, 스프링이란 명칭의 어원은 객체지향 개발의 혹한의 겨울이었던 EJB(Enterprise Java Bean)를 지나 JAVA와 DI 그리고 IOC 와 Container라는 개념이 접목되어 드디어 객체지향 개발에 봄이 찾아왔다 라는 의미를 담고있습니다. 

스프링이라는 프레임워크의 시스템 전체를 총괄하는 스프링 컨테이너와 Backend의 역할인 웹서버(Tomcat등), DB연동(JDBC, JPA), RestAPI방식의 Front와의 통신과 다른 서버와의 통신 등을 담당하는 스프링 부트, 스프링 전체의 시스템이 매끄럽게 작업되거나 개발자를 위한 다양한 라이브러리를 지원하는 스프링 프레임워크 이렇게 세가지를 합쳐서 “Spring” 이라고 부릅니다.

## 2. 스프링의 핵심기술

### **1 ) 스프링 컨테이너**

1. **스프링 컨테이너의 정의**
    
    스프링 컨테이너란
    
    > 스프링에서 빈이라는 개념을 통해
    개발자를 대신에
    자바 객체들을 관리해주는 공간
    > 
2. **어노테이션과 빈(Annotation & Bean)**
    
    어노테이션은 스프링 컨테이너에게 자바의 클래스가
    
    “어떤 역할을 하게 되는지, 이 클래스는 이 어노테이션의 기능을 하는 클래스입니다.”
    
    라고 알려주는 역할을 하게됩니다.
    
    Bean은 스프링 컨테이너가 자바의 클래스와 메소드를 이용하는 단위입니다. 클래스나 메소드를 어노테이션을 통해 빈으로 인식하게하고 스프링의 가장 중심이 되는 기능인 의존성 주입(DI)를 가능하게 하는 개념입니다.
    
    이를 위한 대표적인 어노테이션으로는
    
    @Configuration
    
    클래스에 사용하는 어노테이션으로 스프링 컨테이너에게 해당 어노테이션이 붙어있는 클래스는 개발자가 원하는 프로젝트가 가져야하는 설정들을 선언하는 클래스로 만들어 주는 어노테이션입니다.
    
    @Bean
    
    프로젝트 설정 클래스(Configuration)에서 메소드단에 붙는 어노테이션으로 해당 메소드가 호출하는 객체들을 스프링 컨테이너가 싱글톤으로 이용하도록 빈으로 등록하거나, 개발자가 직접 컨트롤할 수 없는 외부 라이브러리를 빈으로 등록해야할때 사용하는 어노테이션 입니다. 
    
    @Component
    
    클래스에 사용하는 어노테이션입니다. 특정 어노테이션을 제외한 대부분의 어노테이션의 기본형이고 해당 클래스를 빈으로 컨테이너에 등록하는 어노테이션입니다. 다른 어노테이션을 지원해주는 클래스를 추적해보면 마지막엔 @Component를 이용해서 빈으로 등록하는 구조로 되어있습니다.
    
    등이 있습니다. 또 중요한 어노테이션들이 많지만 각 기능에 대한 문단에서 서술하겠습니다.
    
3. **싱글톤(Singleton)과 의존성**
    
    자바와 같은 객체지향 언어에서 객체를 선언할 때는 생성자 `new 객체, 자료형()`과 함께 선언합니다. 각 클래스마다 객체를 사용하기 위해 객체 인스턴스를 생성하면, 개발하고자 하는 시스템이 커지고 서비스가 다양해짐에 따라 공통적으로 들어가는 객체의 인스턴스가 너무 많이 생성되는 경우가 생길 수 있습니다.
    
    이를 해결하기 위해 존재하는 개념이 **싱글톤**입니다. 똑같은 객체라면 하나의 인스턴스만 생성하고 다른 클래스에서는 그 인스턴스를 가져다 쓰기만 하는 개념입니다. 하지만 하나의 클래스에서 해당 인스턴스를 호출하고 있을 때는 다른 클래스에서는 호출할 수 없다는 **의존성 문제**가 발생합니다.
    

1. **의존성 주입(DI)과 제어의 역전 (IOC)**
    
    의존성 주입(Dependency Injection)은 메모리 과부화 문제를 해결하기 위한 싱글톤의 **강한 결합**으로 인한 **강한 의존성 문제**를 해결할 수 있도록 해주는 스프링의 중심 기능입니다.
    
    **강한 의존성 문제**를 해결하기 위해서는 **강한 결합**을 **약한 결합**으로 **느슨한 의존성(이하 '의존성')**을 구성해 주어야 합니다. 빈이라는 개념을 이용해 객체의 인스턴스는 하나, 빈을 여러 개 생성하여 해당 객체를 사용하게 되는 클래스들에 빈을 할당해 주고 클래스의 작업이 끝나면 빈을 회수 및 제거하는 시스템을 통해 의존성을 구성합니다.
    
    @Autowired 어노테이션과 `class(객체형 객체명){this.객체명}`를 이용한 생성자를 통해 인스턴스 조차 없이 비어있는 객체를 선언만 해놓고 위에서 구성된 의존성을 주입해주는 것을 DI라고 합니다.
    
    DI로 의존성을 주입하기 위해서는 먼저 의존성을 구성해야 합니다. 이 구성은 개발자가 직접 코딩하지 않습니다. 스프링 컨테이너 안의 IOC 컨테이너가 개발자가 제어해야 할 객체 인스턴스의 생성 할당 등을 대신 제어해준다고 하여 제어의 역전 IOC라고 합니다.
    
    ![스크린샷 2023-04-21 221013.png](Spring%20Backend%20%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%20%E1%84%90%E1%85%A1%E1%86%B7%E1%84%80%E1%85%AE%20%E1%84%87%E1%85%A9%E1%84%80%E1%85%A9%E1%84%89%E1%85%A5%206bbf7b7f4c5a477e9eab2e9d35c03c1a/%25EC%258A%25A4%25ED%2581%25AC%25EB%25A6%25B0%25EC%2583%25B7_2023-04-21_221013.png)
    
    - 정리
        - **싱글톤을 사용하는 이유**
            
            하나의 인스턴스를 재사용하기 위함입니다.
            
        - **IOC가 필요한 이유**
            
            강한 결합으로 인한 강한 의존성을 약한 결합으로 풀어내기 위함 입니다.
            
            개발자가 아닌 프레임워크가 인스턴스를 관리하기 때문입니다.
            
        - **DI가 필요한 이유**
            
            전체적인 관리가 진행되려면 인스턴스의 내용을 빈으로만들어 주입해주어야 각 클래스에서 이용할 수 있기 때문입니다.
            
            그래서 IoC 컨테이너에 DI를 하는 것으로 다른 파일에서 사용할 수 있게 됩니다.
            
2. **관심 지향 프로그래밍(AOP)**
    
    시스템을 개발할 때 구현해야 하는 기능들을 가장 큰 분류로는 공통 관심 사항과 핵심 관심 사항으로 분류할 수 있습니다.
    
    핵심 관심 사항은 이 시스템이 가지는 가장 핵심적인 기능들로, 각 회원별로 서비스를 다르게 제공해야 하는 시스템의 경우 회원 가입, 로그인, 마이페이지 등이 있을 것입니다.
    
    여기서 공통 관심 사항은 핵심 관심 사항인 회원 가입, 로그인, 마이페이지 서비스를 포함한 모든 서비스에 공통적으로 적용되어야 하는 보안 로직, 로그인 세션 로직 등이 있습니다.
    
    AOP 공통 관심 서비스를 구현하고 @Aspect 어노테이션을통해 빈으로 등록합니다.그리고 이 서비스를 필요로하는 다른 모든 서비스들에 적용 시켜줍니다.
    
    이러한 시스템을 구성 하였을때 따라오는 장점으로는 공통 관심 로직을 바꾸어야 하는 상황이 왔을때 @Aspect 어노테이션이 붙어있는 클래스만 수정해주면 다른 서비스를 담당하는 클래스를 전혀 수정하지 않아도 됩니다.
    

### **2 ) 스프링 부트**

1. **스프링 부트의 정의**
    
    스프링 부트란
    
    > 스프링으로 애플리케이션을 만들 때에
    필요한 설정을
    간편하게 처리해주는
    별도의 프레임워크.
    > 
    
    DB 연동과 관련된 다양한 설정을 복잡한 코딩 없이 몇 줄로 간단하게 해결할 수 있는 프레임워크입니다.
    
2. **웹서버(Web Server)**
    
    자체적으로 스프링 부트에 웹서버가 내장되어있어 EJB를 통해 개발할 때 처럼 톰캣 등의 웹 서버를 따로 설치해 개발한 파일을 웹 서버에 올려서 실행시키는 구조가 아닌 스프링 자체에서 바로 웹 서버를 가동해 웹 페이지에 띄워 볼 수 있습니다.
    
3. **데이터 접근**
    - 일관된 서비스 추상화(PSA)
    개발환경의 변화가 생겨도 전체적인 코드의 수정없이 다른 개발환경에서도 시스템이 구동되게 하는 추상화라는 개념으로 실질적으로는 백엔드에서 DB와 연동되는 부분에 적용되는 개념입니다.
        
        스프링 부트에서 데이터에 접근하는 방식이란 DB를 참조하는 방식을 말합니다. 관계형데이터베이스(RDB)의 종류가 변경되었을때 서비스 로직의 코딩을 변경하지 않고 개발이 진행되도록하는 개념입니다.
        
        개발 단계에선 가벼운 H2DB나 MongoDB와 같은 NoSql로 개발을 진행하다가 MySql로 변경되었을때, 상용화단계에서 계획이 수정되어 MySql에서 MariaDB로 변경되었을때 이런 상황에서 적용되는 개념입니다.
        
        ![스크린샷 2023-04-21 214301.png](Spring%20Backend%20%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%20%E1%84%90%E1%85%A1%E1%86%B7%E1%84%80%E1%85%AE%20%E1%84%87%E1%85%A9%E1%84%80%E1%85%A9%E1%84%89%E1%85%A5%206bbf7b7f4c5a477e9eab2e9d35c03c1a/%25EC%258A%25A4%25ED%2581%25AC%25EB%25A6%25B0%25EC%2583%25B7_2023-04-21_214301.png)
        
    

### **3 ) 스프링의 프레임 워크**

스프링의 프레임 워크란 스프링 자체도 자바라는 언어의 프레임 워크이지만 스프링을 하나의 언어의 개념을 봐도 될 정도로 단독으로 사용하는 다양한 모듈들이 있습니다. 또 순수 자바에서 사용하는 다른 프레임워크, 라이브러리, 모듈들도 사용할 수 있습니다.

스프링 부트에 TOMCAT, MVC, RESTful 등의 기능들을 기본적으로 내장 시켜주는 웹 개발 시 필수로 추가해야하는 Spring Web모듈부터 개발자를 위한 Spring Boot DevTools모듈등 다양한 모듈이 존재합니다. 

또 Gradle을 통해 모듈을 임포트하면 자동으로 모듈의 최신버전이 아닌 호환성이 가장 좋은 버전을 임포트해줍니다.

위와 같은 스프링의 기능들을 활용해서 스프링을 공부한 사람이라면 SOLID 원칙에 부합하는 시스템을 개발할 수 있습니다. SOLID 원칙은 이상적인 객체 지향 개발의 5가지 요소입니다. 스프링은 순수 자바(POJO)로는 모순이 발생하는 OCP 원칙과 DIP 원칙을 연결시켜줌으로써 이상적인 객체 지향 개발이 가능하도록 돕고, 객체 지향의 특징을 살려줍니다.

## 3. 스프링의 웹 기술

### 1 ) **웹 - 모델, 뷰, 컨트롤러 (Web-MVC)**

Servlet Stack라인의 동작 방식을 따릅니다. Servlet Containers, Servlet API를 통한 하나의 쓰레드에 하나의 요청을 하는 동기 방식의 시스템입니다. 사용자 인터페이스와 비즈니스 로직을 분리하여 비즈니스 로직을 수정해야하는 경우 전체적인 코드수정이 아닌 비즈니스 로직만을 수정할 수 있는 시스템을 개발할 수 있습니다.

이름에서 처럼 서버에서 웹으로 객체를 넘겨주는 자료형인 모델(Model) http, css, js등의 프론트를 구성하는 개념인 뷰(View) 또 스프링 부트에 내장되어있는 웹서버에 올라갈 Servlet을 관리해주는 컨트롤러(Controller) 이렇게 세 가지를 지원하는 기능으로 구성되어있습니다.

스프링에서 @Controller 어노테이션을 붙힌 클래스에서 @GetMapping, @PostMapping, @PutMapping, @DeleteMapping과 같은 어노테이션을 각각의 메소드에 붙혀서 HTTP 메소드 GET, POST, PUT, DELETE 역할을 하게 합니다.

이렇게 어노테이션으로 스프링 컨테이너에 빈으로 등록하면 스프링이 자동으로 스프링 부트에 내장된 웹 서버에 올려서 웹 페이지가 동작 하게합니다.

아래는 @Controller를 사용한 예시 코드입니다.

```java
@Controller
public class MemberViewController { // 웹페이지에서 회원 가입을 통제하는 컨트롤러

		@Autowired
		ServiceRepository serviceRepository;
		// 회원가입 서비스를 구현한 로직이 담긴 객체를 DI구조로 선언한 모습 
		public MemberViewController(ServiceRepository serviceRepository) {
	        this.serviceRepository = serviceRepository;
		}
		// HTTP Sevelet GET메소드를 구현
		@GetMapping("/joinMember") 
		public String JoinMember() {
			return "member/createMemberFrom";
		} // 회원가입 페이지(createMemberFrom.html)를 열어주는 로직
	
		// HTTP Sevelet POST메소드를 구현
		@PostMapping("/joinMember")
		public String JoinMember(Member member) {
			serviceRepository.joinMember(member)
			return "redirect:/";
		}// 회원가입(joinMember)서비스 로직을 실행하고 '/' 페이지로 돌아가게 하는 로직
}
```

### 2 ) **웹 플럭스(WebFlux)**

 Reactive Stack라인의 동작 방식을 따릅니다. Netty, Reactive Stream Adapters를 통한 비동기 논-블로킹(Asynchronous ****Non-blocking) 방식의 시스템입니다. 함수형 엔드포인트와 이벤트에 대한 동시성(concurrency)을 적용한 모델을 지원합니다. 

- **비동기(Asynchronous)**
    
    하나의 쓰레드가 여러개의 요청을 처리하는 비동기방식을 기반으로 하는 비동기 입출력 (Asynchronous I/O)방식을 지향한다
    
- **논-블록킹(Non-blocking)**
    - **논-블로킹 알고리즘(Non-blocking Algorism)**
    다른 스레드에게 영향을 미치지 않도록 어떤 쓰레드에서 오류가 발생하거나 멈추었을 때 이를 처리하는 알고리즘을 의미합니다.
    - **논 블로킹 입/출력(Non-blocking I/O)**
    입출력 처리는 시작만 해둔 채 완료되지 않은 상태에서 다른 처리 작업을 계속 진행할 수 있도록 멈추지 않고 입출력 처리를 기다리는 방법을 말합니다.
- **동시성(concurrency)**
    
    각 프로그램 조각들이 실행 순서와 무관하게 동작할 수 있도록 만들어, 한 번에 여러 개의 작업을 처리할 수 있는 구조입니다.
    

기존 Servlet의 동기 블록형 방식에서는 동시성 모델을 구현하는 데 문제가 발생했습니다. 이를 해결하기 위해 논 블로킹 개념을 섞어 동기 논 블록킹 개념인 Servlet 3.1+가 도입되었지만, 기존 방식의 Servlet API의 기능들과 공존시키기 어렵다는 문제가 발생하게 되고 고질적인 동기 방식의 문제가 제대로 해결되지않아 Servlet API가 아닌 Netty를 통한 비동기 논블로킹 웹 컨트롤러인 WebFlux가 등장하게 됩니다.

### 3 ) 둘의 공통점과 차이점 정리

1. 공통점
    
    공통적으로 @Controller 어노테이션을 사용하여 동작하며, 반응형 클라이언트를 지원합니다. 또한, Tomcat, Jetty, Undertow 이 세 가지 웹 서버를 공통으로 지원합니다.
    
2. 차이점
    1. MVC
        
        Servlet 3.1+ 버전에서는 비동기(non-blocking)를 지원하지만, 여전히 문제가 발생하여 실질적으로는 일반적인 Servlet 개념으로 하나의 쓰레드에 하나의 요청하는 동기방식으로 작동합니다.
        
        명령형 프로그래밍을 사용하여 사용자 인터페이스와 비즈니스 로직을 분리하고 쉽게 디버깅할 수 있습니다.
        
        JDBC, JPA와 같은 네트워킹 API를 이용한 데이터 접근 기술을 사용한다면 MVC를 사용해야 합니다.
        
    2. FLUX
        
        비동기 논-블로킹(Non-blocking) 방식을 이용하여 동시성을 활용하여 적은 양의 스레드로 많은 이벤트를 처리하는 것이 용이합니다.
        
        Mono와 Flux라는 단위의 Reactor객체를 이용한 함수형 엔드포인트를 가지고 있습니다.
        
        네티(Netty)는 NIO 클라이언트 기반의 웹 서버로, 프로토콜 서버 및 클라이언트와 같은 네트워크 응용 프로그램을 빠르고 쉽게 개발할 수 있도록 도와줍니다. Netty를 사용함으로써 Netty가 가지는 빠르고 쉬운 사용성과 다양한 바이너리 및 텍스트 기반 레거시 프로토콜을 지원한다는 장점을 가질 수 있습니다.
        

스프링의 웹 기술을 선정할 때는 각 서비스 로직의 역할에 맞게 MVC가 더 효율적인 서비스 로직에는 MVC로 WebFlux가 더 효율적인 서비스 로직은 WebFlux로 개발하는 것이 좋습니다.

## 4. 스프링의 데이터 접근 기술

### 1 ) 트랜잭션(**Transaction)**

데이터 베이스의 특징인 원자성 일관성 격리성 지속성을 지키기 위한 개념입니다. 업무처리의 최소단위라는 의미를 가지며 스프링에서는 테스트 구현체와 디비 연동에서 아래의 어노테이션을 통해 작동합니다.

@Transactional

해당 클래스를 하나의 트랜잭션으로 묶어서 작업이 끝난 후 DB나 페이지에 적용되는 것을 작업이 정상적으로 이루어져야 적용되게 합니다. 작업이 정상적으로 처리되지않으면 트랜잭션 자체를 롤백해서 없던 일로 만듭니다. 테스트 구현체에 사용하면 테스트에 이용된 데이터들을 테스트를 실행에 서비스 로직을 점검하고 테스트로인한 데이터가 DB에 저장되지않도록 롤백하는 역할도 지원합니다.

### 2 )자바 데이터베이스 접속가능성**(JDBC)**

JDBC는 자바에서 데이터베이스에 접근하는 프레임 워크중 하나입니다. JDBC가 지원하는java.sql.* 패키지의  다양한 인터페이스들로 개발자가 DB참조를 개발하면 JDBC드라이버가 이를 DBMS가 이해할 수 있는 형태로 변환해주고 그것을 토대로 DB에 적용 됩니다.

java.sql.* 패키지의 대표적인 인터페이스는 아래와 같습니다.

- java.sql.Driver 와 java.sql.Connection - DB연결부를 구성하는 인터페이스 입니다. Driver로 부터 Connection객체를 불러와 DB 연결부를 구성합니다.
- java.sql.Statement - DB에 SQL query문을 전송하는 방법이 정의 되어있는 인터페이스 입니다. Connection을 통해 객체를 가져와 사용합니다.
- java.sql.ResultSet - Select문의 실행 결과를 확인하는 방법이 정의 되어있는 인터페이스 입니다.

대표적으로 네 가지 정도가 있고 데이터접근을 수월하게 하는 다양한 인터페이스들이 정의 되어있습니다.

### 3 )객체와 관계 매핑(ORM)과 ****자바 존속 API (JPA**)**

JPA에서의 P는 Persistence, 즉 영속, 존속, 지속성, 고집이라는 뜻을 가지고 있습니다. 이는 데이터를 자바를 통해 디비에 지속적으로 가지고 있는 것을 의미합니다.

JPA의 주요 목적은 ORM을 사용하기 위한 사용 설명서입니다. JPA 인터페이스가 지원하는 메소드만으로 ORM이 가능하게 합니다.

여기서 ORM이란 SQL query문 없이 직관적인 코드를 통해 메소드만으로 데이터를 접근하게 해주는 개념입니다.

DB의 테이블 개념을 자바에서 객체와 동일하게 함으로써 SQL query문 없이 데이터를 접근하게 해주는 시스템입니다.

테이블과 내용이 같은 클래스를 생성하고 @Entity 어노테이션으로 이 객체는 JPA가 테이블로 인식하게합니다. @ Id 어노테이션과 @Column어노테이션으로 해당 클래스 내의 필드들을 Primary Key와 테이블의 컬럼으로써 컬럼명과 매핑 시켜줍니다. 아래는 예시 코드입니다.

```java
@Entity // JPA 테이블임을 명시하는 어노테이션
@Getter
@Setter
// 객체의 필드에 접근하기 위해 해야하는 Getter & Setter를
// 코딩없이 해결해주는 @Getter, @Setter 어노테이션
public class Member {

		@Id
		private long memberId //memberId는 Primary Key

		@Column(name = "Name") //name변수을 테이블에서 Name이라는 컬럼으로 등록
		private String name;

		private Int age; // 특이사항이 없는 일반 컬럼은 그냥 선언
}
```

변수명을 기준으로 쿼리 메서드를 작성하게 되는데 첫 글자는 대문자가 불가능하다 변수명 중간에 ‘_’ 와 같은 특수 기호는 인식되지 않는다 같은 규칙들이 존재합니다. 이때 @Column어노테이션의 name속성으로 적용시켜줄 수 있습니다.

이렇게 ORM에 알맞는 객체형 테이블을 선언하고 서비스 로직에서 JPA의 SQL query를 대신하는 메소드를 이용해 데이터 접근을 설계하면 됩니다. 이때 인터페이스인 JPA의 구현체 역할을 해주는 Hirenate에서 메소드들을 관리하는 객체인 EntityManager를 빈으로 등록해 JPA 메소드들을 호출하여 사용합니다. 아래는 예시 코드입니다.

```java
@Repository
public class JpaMemberRepository implements MemberRepository{

    @Autowired
    private final EntityManager em;

    public JpaMemberRepository(EntityManager em) {
        this.em = em;
    }

    @Override
    public Member save(Member member) {
        em.persist(member); // JPA의 문법인 persist 영구 저장을 의미
        return member;      // insert문과 비슷한 구문
    }

    @Override
    public Optional<Member> findById(String id) {
        Member member = em.find(Member.class, id); // select * from table 
        return Optional.ofNullable(member);        // where id == member.id ;
    }                                              // 정도로 해석할 수 있는 구문

    @Override
    public List<Member> findAll() {
        return em.createQuery("select m from Member m", Member.class)
                .getResultList();
				/* JPA에서 지원하는 문법만으로 해결하지 못하는 쿼리문의 경우
						JPA의 쿼리 문인 JPQL을 createQuery로 직접 쿼리문을 작성 */
    }
}
```

JPA를 여기까지만 공부했을때는 “간편해 지긴 했지만 결국엔 JPA도 복잡한 쿼리를 해결하려면 SQL query 대신 JPQL을 공부해야하고 또 객체를 ORM구조로 만드는걸 공부 해야하는 거잖아.” 라는 생각이 들었습니다. 하지만 여기서 Spring과 JPA가 융합된 프레임 워크 SpringDataJPA가 등장합니다.

SpringDataJPA는 인터페이스만으로 데이터 접근을 할 수 있게 합니다. 아래는 예시 코드입니다.

```java
@Repository
public interface MemberRepository extends JpaRepository< Member, Long > {

    List<Member> findFirst5ByNameOrderByUserIdDesc(String Name);
		// find/First5/ByName/OrderByUserId/Desc
		// 찾아라/맨앞에 5개/이름을 기준으로/아이디로 정렬해서/정렬 기준 = 역순
		// 입력받은 이름과 같은 이름을 가진 사람들을 Id의 역순으로 출력해라라는 의미

    long countByName(Int age);
		// count/ByName
    // 세어라/이름을
		// 같은 나이를 가진 이름들을 세어달라는 의미
    
}
```

인터페이스를 레파지토리로 등록하고 SpringDataJPA의 JpaRepository를 상속받아 인터페이스의 메소드 이름을 작성해 메소드 이름 자체가 DB를 참조하는 기능이 되는 것 입니다.

이렇게 인터페이스 만으로 기능 로직을 구현하고 이 기능 로직들을 이용해 서비스 로직을 작성하면 사용자 클라이언트에서 서비스가 호출될 때 마다 데이터에 접근하여 값을 가져와 사용자에게 알려줍니다.

- 정리
    
    

### 4 )확장형 마크업 언어 (XML)

HTML과 비슷한 태그 기반의 문법을 사용하는 마크업 언어입니다. 다양한 종류의 데이터를 손쉽게 교환할 수 있도록하는 목적을 가지고 있습니다. 예를 들어 DB의 데이터를 웹 사이트 데이터로 다시 웹 사이트 데이터를 회사 회계 처리 시스템의 데이터로 이런식의 매우 다양한 종류의 데이터 형식으로 손쉽게 교환 할 수 있도록 하는 언어입니다. 

## D. 스프링의 테스트 구현체

- 자체적인 코드 테스트 지원
    
    스프링은 어떤 로직을 구현하더라도 자체적으로 테스트를 해볼 수 있는 시스템을 지원합니다.
    
    테스트가 쉽기 때문에 테스트 주도 개발(Test Driven Development) as TTD를 기반으로 정말 작은 단위의 로직부터 하나하나 테스트 해보며 개발해 볼 수 있습니다.
    
    절차지향 프로그래밍에선 코딩을 다 마치고 컴파일 후 결과가 제대로 나오는지 테스트 혹은 디버깅을 해봐야하지만 스프링은 메소드 하나 단위의 로직부터 테스트를 해보며 개발할 수 있기 때문에 객체 지향의 장점을 더욱 살릴 수 있는 프레임 워크입니다.
    
    가장 작은 메소드 하나 단위로도 테스트 해 볼 수 있지만 보통의 테스트 구현체의 경우 의사 코드로만 작성 후 TTD기반으로 기능 로직 클래스를 구현 후 기능 로직을 테스트하는 방식으로 하나의 로직단위로 테스트 구현체를 구현하는 경우가 많습니다.
    
    이때, 적어도 해당 로직 안의 메소드들은 동시에 작동해도 문제가 없는지 테스트 해야봐야합니다. 아래의 어노테이션들로 위의 기능들을 빈으로 등록해 사용할 수 있습니다.
    
    @Test
    
    이 어노테이션은 테스트 구현체 클래스의 메소드에 붙어, 해당 테스트 메소드를 통해 기능 로직 또는 서비스 로직의 기능 메소드나 서비스 메소드를 테스트하도록 스프링 컨테이너에 알리는 역할을 합니다.또 기능, 서비스 메소드 하나씩 실행할 수 있는 기능이 활성화되며, 로직 하나가 동시에 실행되는지 테스트할 수 있는 기능도 활성화됩니다.
    
    @SpringBootTest
    
    테스트 구현체 클래스에 붙는 어노테이션으로 DB의 데이터 접근 등의 네트워크API가 들어간 로직을 테스트 할 때는 해당 메소드만 SpringBoot위에 올려서 테스트하도록 스프링 컨테이너에게 알려주는 역할을 합니다.
    
    @Transactional 
    
    위의 트랜잭션 문단에서도 간단하게 서술한 내용처럼 테스트 구현체에 이 어노테이션을 붙히면 테스트 구현체 전체를 통해 테스트 할 때 테스트 메소드를 하나의 트랜잭션으로 묶어서 메소드의 동작이 끝나면 롤백하는 방식으로 모든 테스트 메소드에 사용하는 더미 값을 같게 해도 서로 출동이 나지 않게 하고 기능적인 테스트만 진행 할 수 있도록 합니다.
    
    또 DB에 값을 넣어보는 서비스 단위의 테스트의 경우 DB 값이 잘 들어가는지 테스트 후 해당 트랜잭션을 롤백하여 DB에서 더미 값을 청소해줌으로써 다음 메소드가 동작하는데 잘못된 값이 나오거나 충돌이 발생하는 일을 방지하고 기능적인 테스트만 진행 할 수 있도록 합니다.
    

## E. 스프링의 언어

- 자바(Java), 코틀린(Kotlin), 그루비(Groovy)
    
    스프링에서 지원하는 프로그래밍 언어는 총 세가지입니다. 자바와 자바를 기반으로한 두 가지 프로그래밍 언어 Kotlin과 Groovy입니다.
    
    첫번째로 객체 지향 언어하면 가장 먼저 떠오르는 Java입니다. 제가 이번 프로젝트에 사용하게 될 언어입니다. 
    
    자바 기반의 언어이고 자바도 엄청 어려운 문법을 가지지는 않지만 자바랑 비교해도 엄청나게 간결한 문법을 제공하는 Kotlin입니다. 크게 오버헤드가 없는 널 안정성과 예외처리를 강제하지 않는다는 점이 장점입니다.
    
    자바와 문법이 거의 동일한Groovy입니다. Java 프로그래머라면 금방 적응해서 쓸 수 있습니다. 차이점은 public, private 등의 접근 레벨 지시자나 세미콜론 등이 옵션이라는 것 정도며 자바에서는 지원되지 않는 클로저 함수가 지원되고 함수형 프로그래밍이 가능합니다.
    